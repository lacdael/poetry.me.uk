{"version":3,"file":"329-19f0c7e07fabc5f4bc1d.js","mappings":"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","sources":["webpack://poetry.me.uk/./node_modules/viem/_esm/errors/ccip.js","webpack://poetry.me.uk/./node_modules/viem/_esm/utils/ccip.js","webpack://poetry.me.uk/./node_modules/viem/_esm/utils/address/isAddressEqual.js"],"sourcesContent":["import \"core-js/modules/es.array.unscopables.flat.js\";\nimport { stringify } from '../utils/stringify.js';\nimport { BaseError } from './base.js';\nimport { getUrl } from './utils.js';\nexport class OffchainLookupError extends BaseError {\n  constructor(_ref) {\n    var _cause$metaMessages;\n    let {\n      callbackSelector,\n      cause,\n      data,\n      extraData,\n      sender,\n      urls\n    } = _ref;\n    super(cause.shortMessage || 'An error occurred while fetching for an offchain result.', {\n      cause,\n      metaMessages: [...(cause.metaMessages || []), (_cause$metaMessages = cause.metaMessages) !== null && _cause$metaMessages !== void 0 && _cause$metaMessages.length ? '' : [], 'Offchain Gateway Call:', urls && ['  Gateway URL(s):', ...urls.map(url => \"    \".concat(getUrl(url)))], \"  Sender: \".concat(sender), \"  Data: \".concat(data), \"  Callback selector: \".concat(callbackSelector), \"  Extra data: \".concat(extraData)].flat()\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'OffchainLookupError'\n    });\n  }\n}\nexport class OffchainLookupResponseMalformedError extends BaseError {\n  constructor(_ref2) {\n    let {\n      result,\n      url\n    } = _ref2;\n    super('Offchain gateway response is malformed. Response data must be a hex value.', {\n      metaMessages: [\"Gateway URL: \".concat(getUrl(url)), \"Response: \".concat(stringify(result))]\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'OffchainLookupResponseMalformedError'\n    });\n  }\n}\nexport class OffchainLookupSenderMismatchError extends BaseError {\n  constructor(_ref3) {\n    let {\n      sender,\n      to\n    } = _ref3;\n    super('Reverted sender address does not match target contract address (`to`).', {\n      metaMessages: [\"Contract address: \".concat(to), \"OffchainLookup sender address: \".concat(sender)]\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'OffchainLookupSenderMismatchError'\n    });\n  }\n}","import { call } from '../actions/public/call.js';\nimport '../errors/base.js';\nimport { OffchainLookupError, OffchainLookupResponseMalformedError, OffchainLookupSenderMismatchError } from '../errors/ccip.js';\nimport { HttpRequestError } from '../errors/request.js';\nimport { decodeErrorResult } from './abi/decodeErrorResult.js';\nimport { encodeAbiParameters } from './abi/encodeAbiParameters.js';\nimport { isAddressEqual } from './address/isAddressEqual.js';\nimport { concat } from './data/concat.js';\nimport { isHex } from './data/isHex.js';\nimport { stringify } from './stringify.js';\nexport const offchainLookupSignature = '0x556f1830';\nexport const offchainLookupAbiItem = {\n  name: 'OffchainLookup',\n  type: 'error',\n  inputs: [{\n    name: 'sender',\n    type: 'address'\n  }, {\n    name: 'urls',\n    type: 'string[]'\n  }, {\n    name: 'callData',\n    type: 'bytes'\n  }, {\n    name: 'callbackFunction',\n    type: 'bytes4'\n  }, {\n    name: 'extraData',\n    type: 'bytes'\n  }]\n};\nexport async function offchainLookup(client, _ref) {\n  let {\n    blockNumber,\n    blockTag,\n    data,\n    to\n  } = _ref;\n  const {\n    args\n  } = decodeErrorResult({\n    data,\n    abi: [offchainLookupAbiItem]\n  });\n  const [sender, urls, callData, callbackSelector, extraData] = args;\n  try {\n    if (!isAddressEqual(to, sender)) throw new OffchainLookupSenderMismatchError({\n      sender,\n      to\n    });\n    const result = await ccipFetch({\n      data: callData,\n      sender,\n      urls\n    });\n    const {\n      data: data_\n    } = await call(client, {\n      blockNumber,\n      blockTag,\n      data: concat([callbackSelector, encodeAbiParameters([{\n        type: 'bytes'\n      }, {\n        type: 'bytes'\n      }], [result, extraData])]),\n      to\n    });\n    return data_;\n  } catch (err) {\n    throw new OffchainLookupError({\n      callbackSelector,\n      cause: err,\n      data,\n      extraData,\n      sender,\n      urls\n    });\n  }\n}\nexport async function ccipFetch(_ref2) {\n  let {\n    data,\n    sender,\n    urls\n  } = _ref2;\n  let error = new Error('An unknown error occurred.');\n  for (let i = 0; i < urls.length; i++) {\n    const url = urls[i];\n    const method = url.includes('{sender}') || url.includes('{data}') ? 'GET' : 'POST';\n    const body = method === 'POST' ? {\n      data,\n      sender\n    } : undefined;\n    try {\n      var _response$headers$get;\n      const response = await fetch(url.replace('{sender}', sender).replace('{data}', data), {\n        body: JSON.stringify(body),\n        method\n      });\n      let result;\n      if ((_response$headers$get = response.headers.get('Content-Type')) !== null && _response$headers$get !== void 0 && _response$headers$get.startsWith('application/json')) {\n        result = (await response.json()).data;\n      } else {\n        result = await response.text();\n      }\n      if (!response.ok) {\n        error = new HttpRequestError({\n          body,\n          details: stringify(result.error) || response.statusText,\n          headers: response.headers,\n          status: response.status,\n          url\n        });\n        continue;\n      }\n      if (!isHex(result)) {\n        error = new OffchainLookupResponseMalformedError({\n          result,\n          url\n        });\n        continue;\n      }\n      return result;\n    } catch (err) {\n      error = new HttpRequestError({\n        body,\n        details: err.message,\n        url\n      });\n    }\n  }\n  throw error;\n}","import { InvalidAddressError } from '../../errors/address.js';\nimport { isAddress } from './isAddress.js';\nexport function isAddressEqual(a, b) {\n  if (!isAddress(a)) throw new InvalidAddressError({\n    address: a\n  });\n  if (!isAddress(b)) throw new InvalidAddressError({\n    address: b\n  });\n  return a.toLowerCase() === b.toLowerCase();\n}"],"names":["OffchainLookupError","constructor","_ref","_cause$metaMessages","callbackSelector","cause","data","extraData","sender","urls","super","shortMessage","metaMessages","length","map","url","concat","flat","Object","defineProperty","this","enumerable","configurable","writable","value","OffchainLookupResponseMalformedError","_ref2","result","stringify","OffchainLookupSenderMismatchError","_ref3","to","offchainLookupSignature","offchainLookupAbiItem","name","type","inputs","async","offchainLookup","client","blockNumber","blockTag","args","decodeErrorResult","abi","callData","a","b","isAddress","address","toLowerCase","isAddressEqual","ccipFetch","data_","call","encodeAbiParameters","err","error","Error","i","method","includes","body","undefined","_response$headers$get","response","fetch","replace","JSON","headers","get","startsWith","json","text","ok","details","statusText","status","isHex","message"],"sourceRoot":""}